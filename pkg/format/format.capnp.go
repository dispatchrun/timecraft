// Code generated by capnpc-go. DO NOT EDIT.

package format

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Compression uint16

// Compression_TypeID is the unique identifier for the type Compression.
const Compression_TypeID = 0xa7b3bd88a0fe9659

// Values of Compression.
const (
	Compression_uncompressed Compression = 0
	Compression_snappy       Compression = 1
	Compression_zstd         Compression = 2
)

// String returns the enum's constant name.
func (c Compression) String() string {
	switch c {
	case Compression_uncompressed:
		return "uncompressed"
	case Compression_snappy:
		return "snappy"
	case Compression_zstd:
		return "zstd"

	default:
		return ""
	}
}

// CompressionFromString returns the enum value with a name,
// or the zero value if there's no such value.
func CompressionFromString(c string) Compression {
	switch c {
	case "uncompressed":
		return Compression_uncompressed
	case "snappy":
		return Compression_snappy
	case "zstd":
		return Compression_zstd

	default:
		return 0
	}
}

type Compression_List = capnp.EnumList[Compression]

func NewCompression_List(s *capnp.Segment, sz int32) (Compression_List, error) {
	return capnp.NewEnumList[Compression](s, sz)
}

type MemoryAccessType uint16

// MemoryAccessType_TypeID is the unique identifier for the type MemoryAccessType.
const MemoryAccessType_TypeID = 0xb3ad297d8e723e91

// Values of MemoryAccessType.
const (
	MemoryAccessType_read  MemoryAccessType = 0
	MemoryAccessType_write MemoryAccessType = 1
)

// String returns the enum's constant name.
func (c MemoryAccessType) String() string {
	switch c {
	case MemoryAccessType_read:
		return "read"
	case MemoryAccessType_write:
		return "write"

	default:
		return ""
	}
}

// MemoryAccessTypeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func MemoryAccessTypeFromString(c string) MemoryAccessType {
	switch c {
	case "read":
		return MemoryAccessType_read
	case "write":
		return MemoryAccessType_write

	default:
		return 0
	}
}

type MemoryAccessType_List = capnp.EnumList[MemoryAccessType]

func NewMemoryAccessType_List(s *capnp.Segment, sz int32) (MemoryAccessType_List, error) {
	return capnp.NewEnumList[MemoryAccessType](s, sz)
}

type Hash capnp.Struct

// Hash_TypeID is the unique identifier for the type Hash.
const Hash_TypeID = 0xd298d40dfac51430

func NewHash(s *capnp.Segment) (Hash, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Hash(st), err
}

func NewRootHash(s *capnp.Segment) (Hash, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Hash(st), err
}

func ReadRootHash(msg *capnp.Message) (Hash, error) {
	root, err := msg.Root()
	return Hash(root.Struct()), err
}

func (s Hash) String() string {
	str, _ := text.Marshal(0xd298d40dfac51430, capnp.Struct(s))
	return str
}

func (s Hash) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Hash) DecodeFromPtr(p capnp.Ptr) Hash {
	return Hash(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Hash) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Hash) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Hash) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Hash) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Hash) Algorithm() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Hash) HasAlgorithm() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Hash) AlgorithmBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Hash) SetAlgorithm(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Hash) Digest() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Hash) HasDigest() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Hash) DigestBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Hash) SetDigest(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Hash_List is a list of Hash.
type Hash_List = capnp.StructList[Hash]

// NewHash creates a new list of Hash.
func NewHash_List(s *capnp.Segment, sz int32) (Hash_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Hash](l), err
}

// Hash_Future is a wrapper for a Hash promised by a client call.
type Hash_Future struct{ *capnp.Future }

func (f Hash_Future) Struct() (Hash, error) {
	p, err := f.Future.Ptr()
	return Hash(p.Struct()), err
}

type Function capnp.Struct

// Function_TypeID is the unique identifier for the type Function.
const Function_TypeID = 0xdaebd670d0c07620

func NewFunction(s *capnp.Segment) (Function, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Function(st), err
}

func NewRootFunction(s *capnp.Segment) (Function, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Function(st), err
}

func ReadRootFunction(msg *capnp.Message) (Function, error) {
	root, err := msg.Root()
	return Function(root.Struct()), err
}

func (s Function) String() string {
	str, _ := text.Marshal(0xdaebd670d0c07620, capnp.Struct(s))
	return str
}

func (s Function) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Function) DecodeFromPtr(p capnp.Ptr) Function {
	return Function(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Function) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Function) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Function) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Function) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Function) Module() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Function) HasModule() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Function) ModuleBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Function) SetModule(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Function) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Function) HasName() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Function) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Function) SetName(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Function_List is a list of Function.
type Function_List = capnp.StructList[Function]

// NewFunction creates a new list of Function.
func NewFunction_List(s *capnp.Segment, sz int32) (Function_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Function](l), err
}

// Function_Future is a wrapper for a Function promised by a client call.
type Function_Future struct{ *capnp.Future }

func (f Function_Future) Struct() (Function, error) {
	p, err := f.Future.Ptr()
	return Function(p.Struct()), err
}

type Runtime capnp.Struct

// Runtime_TypeID is the unique identifier for the type Runtime.
const Runtime_TypeID = 0x8b3b0e1bb97986da

func NewRuntime(s *capnp.Segment) (Runtime, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Runtime(st), err
}

func NewRootRuntime(s *capnp.Segment) (Runtime, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Runtime(st), err
}

func ReadRootRuntime(msg *capnp.Message) (Runtime, error) {
	root, err := msg.Root()
	return Runtime(root.Struct()), err
}

func (s Runtime) String() string {
	str, _ := text.Marshal(0x8b3b0e1bb97986da, capnp.Struct(s))
	return str
}

func (s Runtime) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Runtime) DecodeFromPtr(p capnp.Ptr) Runtime {
	return Runtime(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Runtime) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Runtime) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Runtime) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Runtime) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Runtime) Runtime() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Runtime) HasRuntime() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Runtime) RuntimeBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Runtime) SetRuntime(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Runtime) Version() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Runtime) HasVersion() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Runtime) VersionBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Runtime) SetVersion(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Runtime) Functions() (Function_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Function_List(p.List()), err
}

func (s Runtime) HasFunctions() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Runtime) SetFunctions(v Function_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewFunctions sets the functions field to a newly
// allocated Function_List, preferring placement in s's segment.
func (s Runtime) NewFunctions(n int32) (Function_List, error) {
	l, err := NewFunction_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Function_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// Runtime_List is a list of Runtime.
type Runtime_List = capnp.StructList[Runtime]

// NewRuntime creates a new list of Runtime.
func NewRuntime_List(s *capnp.Segment, sz int32) (Runtime_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[Runtime](l), err
}

// Runtime_Future is a wrapper for a Runtime promised by a client call.
type Runtime_Future struct{ *capnp.Future }

func (f Runtime_Future) Struct() (Runtime, error) {
	p, err := f.Future.Ptr()
	return Runtime(p.Struct()), err
}

type Process capnp.Struct

// Process_TypeID is the unique identifier for the type Process.
const Process_TypeID = 0xceff67aa4258f9af

func NewProcess(s *capnp.Segment) (Process, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5})
	return Process(st), err
}

func NewRootProcess(s *capnp.Segment) (Process, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5})
	return Process(st), err
}

func ReadRootProcess(msg *capnp.Message) (Process, error) {
	root, err := msg.Root()
	return Process(root.Struct()), err
}

func (s Process) String() string {
	str, _ := text.Marshal(0xceff67aa4258f9af, capnp.Struct(s))
	return str
}

func (s Process) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Process) DecodeFromPtr(p capnp.Ptr) Process {
	return Process(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Process) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Process) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Process) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Process) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Process) Id() (Hash, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Hash(p.Struct()), err
}

func (s Process) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Process) SetId(v Hash) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewId sets the id field to a newly
// allocated Hash struct, preferring placement in s's segment.
func (s Process) NewId() (Hash, error) {
	ss, err := NewHash(capnp.Struct(s).Segment())
	if err != nil {
		return Hash{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Process) Image() (Hash, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Hash(p.Struct()), err
}

func (s Process) HasImage() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Process) SetImage(v Hash) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewImage sets the image field to a newly
// allocated Hash struct, preferring placement in s's segment.
func (s Process) NewImage() (Hash, error) {
	ss, err := NewHash(capnp.Struct(s).Segment())
	if err != nil {
		return Hash{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Process) UnixStartTime() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Process) SetUnixStartTime(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Process) Arguments() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.TextList(p.List()), err
}

func (s Process) HasArguments() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Process) SetArguments(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewArguments sets the arguments field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Process) NewArguments(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Process) Environment() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return capnp.TextList(p.List()), err
}

func (s Process) HasEnvironment() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Process) SetEnvironment(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewEnvironment sets the environment field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Process) NewEnvironment(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}
func (s Process) ParentProcessId() (Hash, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return Hash(p.Struct()), err
}

func (s Process) HasParentProcessId() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Process) SetParentProcessId(v Hash) error {
	return capnp.Struct(s).SetPtr(4, capnp.Struct(v).ToPtr())
}

// NewParentProcessId sets the parentProcessId field to a newly
// allocated Hash struct, preferring placement in s's segment.
func (s Process) NewParentProcessId() (Hash, error) {
	ss, err := NewHash(capnp.Struct(s).Segment())
	if err != nil {
		return Hash{}, err
	}
	err = capnp.Struct(s).SetPtr(4, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Process) ParentForkOffset() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Process) SetParentForkOffset(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

// Process_List is a list of Process.
type Process_List = capnp.StructList[Process]

// NewProcess creates a new list of Process.
func NewProcess_List(s *capnp.Segment, sz int32) (Process_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5}, sz)
	return capnp.StructList[Process](l), err
}

// Process_Future is a wrapper for a Process promised by a client call.
type Process_Future struct{ *capnp.Future }

func (f Process_Future) Struct() (Process, error) {
	p, err := f.Future.Ptr()
	return Process(p.Struct()), err
}
func (p Process_Future) Id() Hash_Future {
	return Hash_Future{Future: p.Future.Field(0, nil)}
}
func (p Process_Future) Image() Hash_Future {
	return Hash_Future{Future: p.Future.Field(1, nil)}
}
func (p Process_Future) ParentProcessId() Hash_Future {
	return Hash_Future{Future: p.Future.Field(4, nil)}
}

type LogHeader capnp.Struct

// LogHeader_TypeID is the unique identifier for the type LogHeader.
const LogHeader_TypeID = 0xc24f9c4986211f3b

func NewLogHeader(s *capnp.Segment) (LogHeader, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return LogHeader(st), err
}

func NewRootLogHeader(s *capnp.Segment) (LogHeader, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return LogHeader(st), err
}

func ReadRootLogHeader(msg *capnp.Message) (LogHeader, error) {
	root, err := msg.Root()
	return LogHeader(root.Struct()), err
}

func (s LogHeader) String() string {
	str, _ := text.Marshal(0xc24f9c4986211f3b, capnp.Struct(s))
	return str
}

func (s LogHeader) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LogHeader) DecodeFromPtr(p capnp.Ptr) LogHeader {
	return LogHeader(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LogHeader) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LogHeader) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LogHeader) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LogHeader) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LogHeader) Runtime() (Runtime, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Runtime(p.Struct()), err
}

func (s LogHeader) HasRuntime() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LogHeader) SetRuntime(v Runtime) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewRuntime sets the runtime field to a newly
// allocated Runtime struct, preferring placement in s's segment.
func (s LogHeader) NewRuntime() (Runtime, error) {
	ss, err := NewRuntime(capnp.Struct(s).Segment())
	if err != nil {
		return Runtime{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s LogHeader) Process() (Process, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Process(p.Struct()), err
}

func (s LogHeader) HasProcess() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s LogHeader) SetProcess(v Process) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewProcess sets the process field to a newly
// allocated Process struct, preferring placement in s's segment.
func (s LogHeader) NewProcess() (Process, error) {
	ss, err := NewProcess(capnp.Struct(s).Segment())
	if err != nil {
		return Process{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s LogHeader) SegmentNumber() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s LogHeader) SetSegmentNumber(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s LogHeader) Compression() Compression {
	return Compression(capnp.Struct(s).Uint16(4))
}

func (s LogHeader) SetCompression(v Compression) {
	capnp.Struct(s).SetUint16(4, uint16(v))
}

// LogHeader_List is a list of LogHeader.
type LogHeader_List = capnp.StructList[LogHeader]

// NewLogHeader creates a new list of LogHeader.
func NewLogHeader_List(s *capnp.Segment, sz int32) (LogHeader_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[LogHeader](l), err
}

// LogHeader_Future is a wrapper for a LogHeader promised by a client call.
type LogHeader_Future struct{ *capnp.Future }

func (f LogHeader_Future) Struct() (LogHeader, error) {
	p, err := f.Future.Ptr()
	return LogHeader(p.Struct()), err
}
func (p LogHeader_Future) Runtime() Runtime_Future {
	return Runtime_Future{Future: p.Future.Field(0, nil)}
}
func (p LogHeader_Future) Process() Process_Future {
	return Process_Future{Future: p.Future.Field(1, nil)}
}

type RecordBatch capnp.Struct

// RecordBatch_TypeID is the unique identifier for the type RecordBatch.
const RecordBatch_TypeID = 0x8ce939ca7fdf463f

func NewRecordBatch(s *capnp.Segment) (RecordBatch, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return RecordBatch(st), err
}

func NewRootRecordBatch(s *capnp.Segment) (RecordBatch, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return RecordBatch(st), err
}

func ReadRootRecordBatch(msg *capnp.Message) (RecordBatch, error) {
	root, err := msg.Root()
	return RecordBatch(root.Struct()), err
}

func (s RecordBatch) String() string {
	str, _ := text.Marshal(0x8ce939ca7fdf463f, capnp.Struct(s))
	return str
}

func (s RecordBatch) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (RecordBatch) DecodeFromPtr(p capnp.Ptr) RecordBatch {
	return RecordBatch(capnp.Struct{}.DecodeFromPtr(p))
}

func (s RecordBatch) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s RecordBatch) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s RecordBatch) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s RecordBatch) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s RecordBatch) FirstOffset() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s RecordBatch) SetFirstOffset(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s RecordBatch) CompressedSize() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s RecordBatch) SetCompressedSize(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

func (s RecordBatch) UncompressedSize() uint32 {
	return capnp.Struct(s).Uint32(12)
}

func (s RecordBatch) SetUncompressedSize(v uint32) {
	capnp.Struct(s).SetUint32(12, v)
}

func (s RecordBatch) Checksum() uint32 {
	return capnp.Struct(s).Uint32(16)
}

func (s RecordBatch) SetChecksum(v uint32) {
	capnp.Struct(s).SetUint32(16, v)
}

func (s RecordBatch) Records() (Record_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Record_List(p.List()), err
}

func (s RecordBatch) HasRecords() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s RecordBatch) SetRecords(v Record_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewRecords sets the records field to a newly
// allocated Record_List, preferring placement in s's segment.
func (s RecordBatch) NewRecords(n int32) (Record_List, error) {
	l, err := NewRecord_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Record_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// RecordBatch_List is a list of RecordBatch.
type RecordBatch_List = capnp.StructList[RecordBatch]

// NewRecordBatch creates a new list of RecordBatch.
func NewRecordBatch_List(s *capnp.Segment, sz int32) (RecordBatch_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[RecordBatch](l), err
}

// RecordBatch_Future is a wrapper for a RecordBatch promised by a client call.
type RecordBatch_Future struct{ *capnp.Future }

func (f RecordBatch_Future) Struct() (RecordBatch, error) {
	p, err := f.Future.Ptr()
	return RecordBatch(p.Struct()), err
}

type Record capnp.Struct

// Record_TypeID is the unique identifier for the type Record.
const Record_TypeID = 0xe06c0aae727f5067

func NewRecord(s *capnp.Segment) (Record, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3})
	return Record(st), err
}

func NewRootRecord(s *capnp.Segment) (Record, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3})
	return Record(st), err
}

func ReadRootRecord(msg *capnp.Message) (Record, error) {
	root, err := msg.Root()
	return Record(root.Struct()), err
}

func (s Record) String() string {
	str, _ := text.Marshal(0xe06c0aae727f5067, capnp.Struct(s))
	return str
}

func (s Record) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Record) DecodeFromPtr(p capnp.Ptr) Record {
	return Record(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Record) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Record) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Record) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Record) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Record) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Record) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Record) Function() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s Record) SetFunction(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

func (s Record) Params() (capnp.UInt64List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt64List(p.List()), err
}

func (s Record) HasParams() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Record) SetParams(v capnp.UInt64List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewParams sets the params field to a newly
// allocated capnp.UInt64List, preferring placement in s's segment.
func (s Record) NewParams(n int32) (capnp.UInt64List, error) {
	l, err := capnp.NewUInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt64List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Record) Results() (capnp.UInt64List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.UInt64List(p.List()), err
}

func (s Record) HasResults() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Record) SetResults(v capnp.UInt64List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewResults sets the results field to a newly
// allocated capnp.UInt64List, preferring placement in s's segment.
func (s Record) NewResults(n int32) (capnp.UInt64List, error) {
	l, err := capnp.NewUInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt64List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Record) Offset() uint32 {
	return capnp.Struct(s).Uint32(12)
}

func (s Record) SetOffset(v uint32) {
	capnp.Struct(s).SetUint32(12, v)
}

func (s Record) Length() uint32 {
	return capnp.Struct(s).Uint32(16)
}

func (s Record) SetLength(v uint32) {
	capnp.Struct(s).SetUint32(16, v)
}

func (s Record) MemoryAccess() (MemoryAccess_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return MemoryAccess_List(p.List()), err
}

func (s Record) HasMemoryAccess() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Record) SetMemoryAccess(v MemoryAccess_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewMemoryAccess sets the memoryAccess field to a newly
// allocated MemoryAccess_List, preferring placement in s's segment.
func (s Record) NewMemoryAccess(n int32) (MemoryAccess_List, error) {
	l, err := NewMemoryAccess_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return MemoryAccess_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// Record_List is a list of Record.
type Record_List = capnp.StructList[Record]

// NewRecord creates a new list of Record.
func NewRecord_List(s *capnp.Segment, sz int32) (Record_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 3}, sz)
	return capnp.StructList[Record](l), err
}

// Record_Future is a wrapper for a Record promised by a client call.
type Record_Future struct{ *capnp.Future }

func (f Record_Future) Struct() (Record, error) {
	p, err := f.Future.Ptr()
	return Record(p.Struct()), err
}

type MemoryAccess capnp.Struct

// MemoryAccess_TypeID is the unique identifier for the type MemoryAccess.
const MemoryAccess_TypeID = 0x818bc0c2e4aa95d4

func NewMemoryAccess(s *capnp.Segment) (MemoryAccess, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return MemoryAccess(st), err
}

func NewRootMemoryAccess(s *capnp.Segment) (MemoryAccess, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return MemoryAccess(st), err
}

func ReadRootMemoryAccess(msg *capnp.Message) (MemoryAccess, error) {
	root, err := msg.Root()
	return MemoryAccess(root.Struct()), err
}

func (s MemoryAccess) String() string {
	str, _ := text.Marshal(0x818bc0c2e4aa95d4, capnp.Struct(s))
	return str
}

func (s MemoryAccess) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (MemoryAccess) DecodeFromPtr(p capnp.Ptr) MemoryAccess {
	return MemoryAccess(capnp.Struct{}.DecodeFromPtr(p))
}

func (s MemoryAccess) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s MemoryAccess) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s MemoryAccess) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s MemoryAccess) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s MemoryAccess) MemoryOffset() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s MemoryAccess) SetMemoryOffset(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s MemoryAccess) RecordOffset() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s MemoryAccess) SetRecordOffset(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

func (s MemoryAccess) Length() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s MemoryAccess) SetLength(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

func (s MemoryAccess) Access() MemoryAccessType {
	return MemoryAccessType(capnp.Struct(s).Uint16(12))
}

func (s MemoryAccess) SetAccess(v MemoryAccessType) {
	capnp.Struct(s).SetUint16(12, uint16(v))
}

// MemoryAccess_List is a list of MemoryAccess.
type MemoryAccess_List = capnp.StructList[MemoryAccess]

// NewMemoryAccess creates a new list of MemoryAccess.
func NewMemoryAccess_List(s *capnp.Segment, sz int32) (MemoryAccess_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[MemoryAccess](l), err
}

// MemoryAccess_Future is a wrapper for a MemoryAccess promised by a client call.
type MemoryAccess_Future struct{ *capnp.Future }

func (f MemoryAccess_Future) Struct() (MemoryAccess, error) {
	p, err := f.Future.Ptr()
	return MemoryAccess(p.Struct()), err
}

const schema_c919885706816759 = "x\xda\x84V\x7f\x88\x14\xe5\x1b\x7f>\xef\xbb\xb3\xb7'" +
	"\xa7{\xe3.|\xf5\xfb\x83\xfb&\x05)\x95?\xae\xc8" +
	"\xcej\xbd\xabDE\xbb{\xef\x84\x12\xfa\xc3q\xf7\xdd" +
	"\xbd\xd1\x9b\x99ufV=\xf18\x8c\x12S/\x152" +
	"\x0c\x14\x14\x8aH(\x03\x0b\x12\x14\x0eI\xa8\xa0\x88\x90" +
	"@Q\xf2\x8f\xa0\xdf\x90\xa0PBM\xbc3\xb73\xc3" +
	"\xea\xe9_\xb7\xfb\xbc\xcf\xbe\xcf\xe7\xf9<\x9f\xe7\xf3\xde" +
	"\xa2\x1e\xbe<\xb3x\xe6B\x8d\x98xR\xcb\x06\x17\x0f" +
	"\x9f\xfc\xfe\xfc\xe4\xbe]$\xe6\x80\x05\xebk\xbb\xb2/" +
	"\xec\x99\xfb9e\xda\x88\xba\xc7\xd8\x02\x14&X\x1bQ" +
	"\xe15\xf6\x03!\xb8\xbc{\xf4\xcc\x7ff-\xdbG\xfa" +
	"\x1c$\xb9\x1aW\xc9\x923\x14\xb6\xa8\x8f\x05\x8b\x9f\"" +
	"\x04\xa5\x15\xdf\x8d\x7f\xf1\xc4O\xfb\xd5\xcd<\x95\x0d\x95" +
	"=73\x0f\x85\xf9a\x95\x072] \x04\xeb\xdf\xfc" +
	"\xfb\xf8\x9es\xa7\xdf%}N\x0a\x07\xa1{\xbd6\x0f" +
	"\x05SS\x17K\xad\x9f\x10\x1cz\xda}}l\xfe\xfb" +
	"\xa7o\xcb\x1c\xd3V\xa3p(\xcc\x9c\xd0\x1e'\x04\xcb" +
	"\xba\xee\xdb\xbd\xeah\xffy\x05!\x0dX\xb5\xd4}H" +
	"\x9b\x8d\xc2\x890\xfb\x98\xa6\xba;\xf5\xe7\x8b}'k" +
	"\xc1W-Th*\xa5\xfbX\x96\xa1\xf0^V}|" +
	"'{@\x01^T\xbcpk\xe6\xc5#\xdf\xb4\x90\x11" +
	"\xd2%s?\x17\xb6\xe4B.r\xdb\x08\xc1\xff\xb7N" +
	"~]\xff\xf6\x97\xcbw\xc8\xed\xfe27\x03\x85\xaba" +
	"\xf2\xa50\xb960\xee~0c\xe4Z+q!\xb7" +
	"\x8f\xb5\xdf*\xf4\xb6\xab\xdf=\xd5~\x00\xb44\xa8o" +
	"\xae-\xac:\xae\xc5\x0d?\xfck\xf8\x8f\x94\x8d\xba]" +
	"\xefY+-\xc7\x1d\xed-\xe7\xcb\xd2\xf3\x06\x00\xd1\xc9" +
	"3D\x19\x10\xe9\xc6&\"\xb1\x81C\x8c0\xe8@\x11" +
	"*h\xaa\xe00\x87\xf0\x19t\xc6\x8a`D\xfa\x96\x1e" +
	"\"1\xc2!\xb63\xe8<[\x04'\xd2\x1b*X\xe7" +
	"\x10;\x19\x02+,\xd3_\xa5|\xd5\x93>r\xc4\x90" +
	"#\x04\xae,;n\xa55\\\x1a\x91v\xcd\x1f\x8e\xbf" +
	"\x1ae\x05\x0e\xf9d\xa6\x04\xe4\x09\xd3w5\xd8\xb0}" +
	"\xd3\x92\xa4\x1a\xea\x88\x1bz\xae\x8fH,\xe7\x10kR" +
	"\x0d\xadR\xc1g9\xc4@\xaa\xa1\xb5\x83Db\x0d\x87" +
	"\x18f\x18w\xa3\xcb\xd0A\x0c\x1d\x84\xf1\xad\xd2\xf5L" +
	"\xc7n~\x0f\xaa\x0d\xbb\xec\x9b\x8eM\xf00\x8b0\xc0" +
	"\x81\xced\x96\x04\x15\xbc\x0b\xd4\x90\x82>\xa3\xcd/\x0f" +
	"+\xb8\xc5\x18\xee\xd8F\"\xb1\x93C\xecQpY\x04" +
	"\xf7\xd5\x1dD\xe2\x15\x0eqP\xc1\xe5\x11\xdc\x89\xbdD" +
	"\xe2 \x878\xaa\xf8\xcfD\xfc\xbf\xb5\x9aH\x1c\xe1\x10" +
	"o3 SD\x86H?\xa1\x9a=\xca!>a\x08" +
	"\xaa\xa6\xeb\xf9\xfd\xd5*\xb5)\xee5b\xd0\x08A\xd9" +
	"\xb1\xea\xae\xf4<*\xc9\xca\x90\xb9C\xc6\xb3j\xd8\xd1" +
	"\x11</:!\x8a\xcf\xca\xc3\xb2\xbc\xd9kX\x94\xc4" +
	"\xc6\xa3\xd9\xa6(\x89\x15{/J\x9e\x99\x82\xd0f:" +
	"v8\xc1\xb0\xc9\xffmR?\xd4\xe7\xf6\x10\x81\xe9\xfa" +
	"\x02\xa2\x18\x12\xe5\x15\xa6\x92g\x1b\xf5\xfah~\x87\xe7" +
	"W\xe2\xcb3\xd3\x09^Ij\xddh]R(\x92\\" +
	"XB]\x0a\xe8\xedK\x88\xf2\xae4*]\xdb\\\xd3" +
	"\x97\xd3\x03]\xe3\xd4VJ\xa3\"\xe1\xb6l\x8e\xa2\xf9" +
	"\xa5H>\xb1\xd0d_\xb2N\x98\xd2\x99\xd9\xa7\x9b]" +
	"b?\x878\xa2&\xc7\xa2\xc9\x1dV\x83\x7f\x83C\x1c" +
	"O\xa9\xaf3\xf1U\x02:\x09\xe3u\xd7\x09\xf7\xa23" +
	"\xf1\xa4\xa9\x13O\xd6,i\xfb\"\x03\x16\\\x9fX\xf8" +
	"\xaf\xd9\x1b\xce\x9c'\x91a\xe8-\x02\x1dD:\xdc`" +
	"(\xcay\x9e\xba\x1a\xd6F\xe9\xa6\x87\xd9T\x80\xe2\x1f" +
	"\xf9\xc4s\xef\xb5u\x03\x11\xa0\x90\xd0\xff\xc6d|\xfc" +
	"o\"\xf1!\x878\x9b\"\xe3\xcc\x12\"\xf1\x11\x87\x98" +
	"L\xc88\xe7\x12\x89\xb3\x1c\xe2\xb3\x14\x17\x17\xd4&~" +
	"\xca!\xae1\xe8\x19\x1e\xc9\xf8\xaa\"\xe8\x0a\x87\xf8\x83" +
	"A\xd72EhD\xfa\xcd\x97\x89\xc4\x0d\x8eA0\xe8" +
	"Y\x14\x91%\xd2\xff\xdaK4\x08\x8e\xa1\x0e0p\xb3" +
	"\x82\xce\xc4\x91#\xb2\xbaL\xcb\xa8\xc9\xdb\xe3A\xc36" +
	"\xb7\x0f\xf9\x86K]\xfe:5\x80\xe6\x82\x18n\xad\xa1" +
	"\x98K\xad\xbbr\x02\xa5hio5]\xc7\xb6\xa8M" +
	"\xda~\xeba\xddp\xa5\xed\x0f\xb8\x08IZU\xa1;" +
	"\xd4\x8crV8p7\xf7W\x95%\x12\xc5u\x9b\xb4" +
	"\xb3V\xda\xf3+\x0d/\xb4\x8e\\\xcc\xf9|\xc5\xda\x83" +
	"\x1c\xe2\xd1\x14\xe7\x8b\x95!?\xc4!\x962\x04\xc6H" +
	"\xcdqM\x7f\x98`5\x8d\xacT1k\xd2\xf3c_" +
	"\x9bv\xce+\x9a\x86G-UU\x81\xfb9\xc4\xa2T" +
	"\xd5\x87\x17$PJ\x96Si\x8c\xc4N\x9a\xb7\x8d\xc4" +
	"V\xa7\xef\xaf\x14Yd\x8b\xaa\x06\x13\x01\xc5\xe6xn" +
	"u\xa2\xa0\xa6\xaa.(P\x93\x1c\xe2\x8aR\x15\"U" +
	"]R\xbbx\x91C\xfc\x9eR\xd5o*\xf3G\x0eq" +
	"#\xa5\xaa\xeb*\xf8\xeb\x94\xd4\xb2,R\xd5\xcdM\x91" +
	"\xd4\x86:\xc1\x10\xa8\xf5\xf4|\xc3\"\xd4\xe3a\xc5o" +
	"B\xb2W\xa5\xba\xe1\x1aV\xac\x99\xf6H\x16\xe3\xae\xf4" +
	"\x1a#~k\xb8\xe4T\xef\xf2\"N=\xa7\xbde\x0a" +
	"\x9f\xed\xc4b\xe3\xff\xd3\"\x8b\xfd'\x00\x00\xff\xff\x09" +
	"\xeb]\xe7"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_c919885706816759,
		Nodes: []uint64{
			0x818bc0c2e4aa95d4,
			0x8b3b0e1bb97986da,
			0x8ce939ca7fdf463f,
			0xa7b3bd88a0fe9659,
			0xb3ad297d8e723e91,
			0xc24f9c4986211f3b,
			0xceff67aa4258f9af,
			0xd298d40dfac51430,
			0xdaebd670d0c07620,
			0xe06c0aae727f5067,
		},
		Compressed: true,
	})
}
